%Ανάλυση εικόνων χρησιμοποιώντας μηχανήματα γραμμικής υποστήριξης φορέα
%{
Αυτό το παράδειγμα δείχνει πώς να προσδιορίσουμε ποιο τεταρτημόριο μιας εικόνας καταλαμβάνει ένα σχήμα εκπαιδεύοντας ένα μοντέλο κωδικών 
εξόδου διόρθωσης σφαλμάτων (ECOC) που αποτελείται από γραμμικούς δυαδικούς μαθητές SVM. 
Αυτό το παράδειγμα απεικονίζει επίσης την κατανάλωση χώρου στο δίσκο των μοντέλων ECOC που αποθηκεύουν διανύσματα υποστήριξης,
τις ετικέτες τους και τους εκτιμώμενους συντελεστές.
%}

%Δημιουργία του συνόλου δεδομένων
%{
Τυχαία τοποθέτηση ενός κύκλου με ακτίνα πέντε σε μια εικόνα 50 προς 50. Δημιουργία 5000 εικόνών. Δημιουργία μιας ετικέτας για κάθε εικόνα που δείχνει το τεταρτημόριο που καταλαμβάνει ο κύκλος.
Το τεταρτημόριο 1 βρίσκεται επάνω δεξιά, το τεταρτημόριο 2 βρίσκεται επάνω αριστερά, το τεταρτημόριο 3 βρίσκεται κάτω αριστερά και το τεταρτημόριο 4 είναι κάτω δεξιά.
Οι προβλέψεις είναι οι εντάσεις κάθε εικονοστοιχείου.
%}
d = 50;  % Ύψος και πλάτος των εικόνων σε pixel
n = 5e4; % Το μέγεθος του δείγματος

X = zeros(n,d^2); % Προκατανομή προμετρίας
Y = zeros(n,1);   % Προκατανομή ετικετών
theta = 0:(1/d):(2*pi);
r = 5;            % Ακτίνα κύκλου
rng(1);           % Για αναπαραγωγιμότητα

for j = 1:n
    figmat = zeros(d);                       % Κενή εικόνα
    c = datasample((r + 1):(d - r - 1),2);   % Κέντρο τυχαίων κύκλων
    x = r*cos(theta) + c(1);                 % Κάνουμε τον κύκλο
    y = r*sin(theta) + c(2);
    idx = sub2ind([d d],round(y),round(x));  % Μετατροπή σε γραμμική ευρετηρίαση
    figmat(idx) = 1;                         % Σχεδιάζουμε τον κύκλο
    X(j,:) = figmat(:);                % Αποθήκευουμε τα δεδομένα
    Y(j) = (c(2) >= floor(d/2)) + 2*(c(2) < floor(d/2)) + ...
        (c(1) < floor(d/2)) + ...
        2*((c(1) >= floor(d/2)) & (c(2) < floor(d/2))); % Προσδιορίζουμε το τεταρτημόριο
end

%Σχεδιάζουμε μια παρατήρηση.
figure;
imagesc(figmat);
h = gca;
h.YDir = 'normal';
title(sprintf('Quadrant %d',Y(end)));

%Εκπαιδεύουμε το ECOC μοντέλο
%Χρησιμοποιούμε ένα δείγμα αναμονής 25% και καθορίζουμε τους δείκτες προπόνησης και δείγματος.
p = 0.25;
CVP = cvpartition(Y,'Holdout',p); % Κατάτμηση δεδομένων πολλαπλής επικύρωσης
isIdx = training(CVP);            % Δείκτες δείγματος εκπαίδευσης
oosIdx = test(CVP);               % Δείκτες δείγματος δοκιμής
%{
Δημιουργούμε ένα πρότυπο SVM που καθορίζει την αποθήκευση των διανυσμάτων υποστήριξης των δυαδικών μαθητών. 
Διαβάζουμε και τα δεδομένα εκπαίδευσης στο fitcecoc για να εκπαιδεύσουμε το μοντέλο.
Προσδιορίζουμε το σφάλμα ταξινόμησης δείγματος εκπαίδευσης.
%}
t = templateSVM('SaveSupportVectors',true);
MdlSV = fitcecoc(X(isIdx,:),Y(isIdx),'Learners',t);
isLoss = resubLoss(MdlSV);

%{
Το MdlSV είναι ένα εκπαιδευμένο μοντέλο ClassificationECOC multiclass. 
Αποθηκεύει τα δεδομένα εκπαίδευσης και τα διανύσματα υποστήριξης κάθε δυαδικού μαθητή.
Για μεγάλα σύνολα δεδομένων, όπως αυτά στην ανάλυση εικόνας, το μοντέλο μπορεί να καταναλώνει πολλή μνήμη.
%}
%Προσδιορίζουμε την ποσότητα χώρου στο δίσκο που καταναλώνει το μοντέλο ECOC.
infoMdlSV = whos('MdlSV');
mbMdlSV = infoMdlSV.bytes/1.049e6;

%Βελτιώνουμε την απόδοση του μοντέλου
%{
Μπορούμε να αξιολογήσουμε την απόδοση εκτός δείγματος. Μπορούμε επίσης να αξιολογήσουμε εάν το μοντέλο ήταν υπερβολικό με ένα συμπαγές μοντέλο
που δεν περιέχει τα διανύσματα υποστήριξης, τις σχετικές παραμέτρους τους και τα δεδομένα εκπαίδευσης.
%}

%Απορρίπτουμε τους φορείς υποστήριξης και τις σχετικές παραμέτρους από το εκπαιδευμένο μοντέλο ECOC. Στη συνέχεια, απορρίπτουμε τα δεδομένα εκπαίδευσης από το μοντέλο που προκύπτει χρησιμοποιώντας το compact.
Mdl = discardSupportVectors(MdlSV);
CMdl = compact(Mdl);
info = whos('Mdl','CMdl');
[bytesCMdl,bytesMdl] = info.bytes;
memReduction = 1 - [bytesMdl bytesCMdl]/infoMdlSV.bytes;

%{
Σε αυτήν την περίπτωση, η απόρριψη των διανυσμάτων υποστήριξης μειώνει την κατανάλωση μνήμης κατά περίπου 3%. Η συμπύκνωση και η απόρριψη διανυσμάτων υποστήριξης μειώνει το μέγεθος κατά περίπου 99,99%.

Ένας εναλλακτικός τρόπος διαχείρισης διανυσμάτων υποστήριξης είναι να μειωθεί ο αριθμός τους κατά τη διάρκεια της προπόνησης, καθορίζοντας έναν μεγαλύτερο περιορισμό κουτιού, όπως το 100.
Αν και τα μοντέλα SVM που χρησιμοποιούν λιγότερα διανύσματα υποστήριξης είναι πιο επιθυμητά και καταναλώνουν λιγότερη μνήμη, αυξάνοντας την τιμή του περιορισμού κουτιού τείνει να αυξήσει τον χρόνο προπόνησης.
%}

%Κατάργηση του MdlSV και του Mdl από τον χώρο εργασίας.
clear Mdl MdlSV;

%Υπολογίζουμε το σφάλμα ταξινόμησης του δείγματος αναμονής. 
%Σχεδιάζουμε ένα δείγμα των προβλέψεων αναμονής.
oosLoss = loss(CMdl,X(oosIdx,:),Y(oosIdx));
yHat = predict(CMdl,X(oosIdx,:));
nVec = 1:size(X,1);
oosIdx = nVec(oosIdx);

figure;
for j = 1:9
    subplot(3,3,j)
    imagesc(reshape(X(oosIdx(j),:),[d d]));
    h = gca;
    h.YDir = 'normal';
    title(sprintf('Quadrant: %d',yHat(j)))
end
text(-1.33*d,4.5*d + 1,'Predictions','FontSize',17)

%Το μοντέλο δεν κατατάσσει εσφαλμένα παρατηρήσεις δείγματος αναμονής